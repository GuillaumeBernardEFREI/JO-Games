Index: basketball/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport random\r\nimport math\r\nimport os\r\nimport basketball.variables as var\r\n#Changed to not have global variables imported in every functions of the runtime.\r\n\r\ndef game_menu(screen):\r\n    menu_running = True\r\n    while menu_running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                pygame.quit()\r\n                exit()\r\n            elif event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_SPACE:\r\n                    menu_running = False\r\n                    return False\r\n                if event.key == pygame.K_ESCAPE:\r\n                    return True #quit the game to the big menu\r\n            elif event.type == pygame.MOUSEBUTTONDOWN:\r\n                if event.button == 1:  # Check if left mouse button is pressed\r\n                    # Check if the mouse cursor is over the play button\r\n                    if var.play_button_rect.collidepoint(event.pos):\r\n                        menu_running = False\r\n                        return False\r\n\r\n        screen.blit(var.menu_surf, var.menu_rect)\r\n        screen.blit(var.play_button_surf, var.play_button_rect)\r\n        pygame.display.update()\r\n\r\ndef basketball(screen):\r\n    if (game_menu(screen)):  # Call the menu before starting the game loop\r\n        #test to exit inside the game menu.\r\n        return\r\n\r\n    var.running = True\r\n    var.game_active = True\r\n    while var.running == True:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                var.running = False\r\n                pygame.quit()\r\n                exit()\r\n            elif event.type == pygame.KEYDOWN and not var.shoot:\r\n                if event.key == pygame.K_RIGHT:\r\n                    var.speed += 1\r\n                    var.memo_speed+=1\r\n                    var.trajectory = True\r\n                elif event.key == pygame.K_LEFT and var.speed >= 10:\r\n                    var.speed -= 1\r\n                    var.memo_speed-=1\r\n                    var.trajectory = True\r\n                elif event.key == pygame.K_SPACE:\r\n                    var.shoot = True\r\n                    var.ball_Sound.play()\r\n                    var.time = 0  # Reset time after shooting\r\n                elif event.key == pygame.K_ESCAPE:\r\n                    return #quit the game to the big menu\r\n\r\n                var.text1 = var.text_font.render(\"Angle : {} \".format(var.angle), True, var.color)\r\n                var.text2 = var.text_font.render(\"Speed : {}\".format(var.speed), True, var.color)\r\n\r\n        var.back_ground_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"basketball court.png\")).convert_alpha(),(950, 600))\r\n\r\n        for time2 in range(0,60,3):\r\n            if var.bouncetest == False:\r\n                var.x_pre = (var.x_ini + math.cos(math.radians(var.angle)) * var.speed * time2)\r\n                var.y_pre = (var.y_ini - (math.sin(math.radians(var.angle)) * var.speed * time2) + 0.5 * var.gravity * time2 ** 2)\r\n                pygame.draw.circle(var.back_ground_surf,'white',(var.x_pre,var.y_pre),5) # preview trajectory with draw circles\r\n\r\n        \"\"\"mouse = pygame.mouse\r\n        if mouse.get_pressed()[0]:\r\n            print(mouse.get_pos())\r\n        mouse = pygame.mouse\"\"\"\r\n        if var.shoot == False:\r\n            var.arrow_x += var.c\r\n            var.angle += var.c\r\n            if var.arrow_x == 382:\r\n                var.c=var.b\r\n            elif var.arrow_x==260:\r\n                var.c=var.a\r\n        var.arrow_power_gauge_rect.center = (var.arrow_x, var.arrow_y)\r\n        var.text1 = var.text_font.render(\"Angle : {} \".format(var.angle), True, var.color)\r\n        if var.shoot == True:\r\n            # Calculate location\r\n            var.x_val = (var.x_ini + math.cos(math.radians(var.angle)) * var.speed * var.time)\r\n            var.y_val = (var.y_ini - (math.sin(math.radians(var.angle)) * var.speed * var.time) + 0.5 * var.gravity * var.time ** 2)\r\n\r\n            if var.y_val + var.ball_surf.get_height() >= var.back_ground_surf.get_height() + 10 or \\\r\n                    var.ball_rect.colliderect(var.hitbox_hopper_rect1) or \\\r\n                    var.ball_rect.colliderect(var.hitbox_hopper_rect2) or \\\r\n                    var.ball_rect.colliderect(var.hitbox_hopper_rect3):\r\n                # Implement bounce\r\n                var.bounce_sound.play()\r\n                var.bouncetest=True\r\n                var.bounce_count += 1\r\n                var.y_val = var.back_ground_surf.get_height() - var.ball_surf.get_height()\r\n                var.speed *= var.retention  # Reduce speed due to bounce\r\n                var.angle = -var.angle  # Reverse angle (simulate bounce)\r\n                var.x_ini = var.x_val\r\n                var.y_ini = var.y_val\r\n                var.time = 0\r\n            if var.ball_rect.colliderect(var.hitbox_hopper_rect1) or var.ball_rect.colliderect(var.hitbox_hopper_rect2) or var.ball_rect.colliderect(var.hitbox_hopper_rect3) :\r\n                # Implement bounce or any other action\r\n                var.bounce_sound.play()\r\n                var.bouncetest = True\r\n                var.bounce_count += 1\r\n                var.y_val = var.hopper_rect.topleft[1]+20 - var.ball_surf.get_height()+20  # Set y_val to the top of the hopper hitbox\r\n                var.speed *= var.retention2  # Reduce speed due to bounce\r\n                var.angle = -var.angle  # Reverse angle (simulate bounce)\r\n                var.x_ini = var.x_val\r\n                var.y_ini = var.y_val\r\n                var.time = 0\r\n            if var.ball_rect.colliderect(var.hitbox_score_rect) and var.played_test==False :\r\n                var.win_sound.play()\r\n                var.played_test=True\r\n                var.angle = 0.0\r\n                var.speed = var.memo_speed\r\n                var.player_rect.midbottom = (random.randint(100, 400),480)\r\n                var.x_val = var.player_rect.x + 70\r\n                var.y_val = var.player_rect.y + 90\r\n                var.x_ini = var.player_rect.x + 70\r\n                var.y_ini = var.player_rect.y + 90\r\n                var.time = 0\r\n                var.bounce_count = 0\r\n                var.shoot = False\r\n                var.bouncetest = False\r\n                var.played_test = False\r\n                var.score += 1\r\n                var.arrow_x = 260\r\n                var.c = var.a\r\n\r\n            elif var.x_val + var.ball_surf.get_width() >= var.back_ground_surf.get_width() or var.bounce_count>=3:\r\n                # Reset ball position and shoot\r\n                var.loose_sound.play()\r\n                var.shoot = False\r\n                var.angle = 0.0\r\n                var.speed = var.memo_speed\r\n                var.player_rect.midbottom = (random.randint(100, 400),480)\r\n                var.x_ini = var.player_rect.x + 70\r\n                var.y_ini = var.player_rect.y + 90\r\n                var.x_val = var.player_rect.x + 70\r\n                var.y_val = var.player_rect.y + 90\r\n                var.time = 0\r\n                var.bounce_count=0\r\n                var.bouncetest=False\r\n                var.played_test=False\r\n                var.arrow_x = 260\r\n                var.c = var.a\r\n                var.ball_rect.center = (var.player_rect.x , var.player_rect.y )\r\n            var.time += 1  # Increment time\r\n        text3 = var.score_font.render(\"{}\".format(var.score), True, 'black')\r\n        var.ball_rect.center = (var.x_val, var.y_val)\r\n\r\n        if var.trajectory :\r\n            var.back_ground_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"basketball court.png\")).convert_alpha(), (950, 600))\r\n        screen.blit(var.hitbox_score_surf, var.hitbox_score_rect)\r\n        screen.blit(var.hitbox_hooper_surf,var.hitbox_hopper_rect2)\r\n        screen.blit(var.hitbox_hooper_surf,var.hitbox_hopper_rect1)\r\n        screen.blit(var.back_ground_surf, var.back_ground_rect)\r\n        current_time = pygame.time.get_ticks()\r\n        animation_index = (current_time // var.animation_speed) % len(var.player_animation_surf)\r\n        screen.blit(var.player_animation_surf[animation_index], var.player_rect)\r\n        screen.blit(var.hopper_surf, var.hopper_rect)\r\n        screen.blit(var.ball_surf, var.ball_rect)\r\n        screen.blit(var.power_gauge_surf, var.power_gauge_rect)\r\n        screen.blit(var.arrow_power_gauge_surf, var.arrow_power_gauge_rect)\r\n        screen.blit(var.score_back_surf, var.score_back_rect)\r\n        screen.blit(text3, (430,100))\r\n        screen.blit(var.text1, (20, 510))\r\n        screen.blit(var.text2, (30, 470))\r\n\r\n        \"\"\"pygame.draw.rect(screen, 'Green', hopper_rect, 5)\r\n        pygame.draw.rect(screen, 'Red', hitbox_hopper_rect1,5)\r\n        pygame.draw.rect(screen,'Red',hitbox_hopper_rect2,5)\r\n        pygame.draw.rect(screen, 'Red', hitbox_hopper_rect3, 5)\r\n        pygame.draw.rect(screen,'Yellow',hitbox_score_rect)\"\"\"\r\n        var.trajectory = False\r\n        var.clock.tick(60)\r\n        pygame.display.update()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/basketball/main.py b/basketball/main.py
--- a/basketball/main.py	(revision 0da02c6a71039a6a74c8400d820c103371daf9e0)
+++ b/basketball/main.py	(date 1715018273036)
@@ -31,12 +31,19 @@
 
 def basketball(screen):
     if (game_menu(screen)):  # Call the menu before starting the game loop
-        #test to exit inside the game menu.
+        #  test to exit inside the game menu.
         return
 
     var.running = True
     var.game_active = True
+
     while var.running == True:
+        current_time = pygame.time.get_ticks()
+        elapsed_time = (current_time - var.shoot_time) // 1000
+        animation_index = (current_time // var.animation_speed) % len(var.player_animation_surf)
+        if elapsed_time % 2 == 0 and elapsed_time != 0 and elapsed_time != var.last_action_time and var.number_of_point>20:  # Make the preview of trajectory less and less precise if the player dont get point
+            var.number_of_point = var.number_of_point - 10
+            var.last_action_time = elapsed_time
         for event in pygame.event.get():
             if event.type == pygame.QUIT:
                 var.running = False
@@ -63,7 +70,7 @@
 
         var.back_ground_surf = pygame.transform.scale(pygame.image.load(os.path.join("basketball","assets","basketball court.png")).convert_alpha(),(950, 600))
 
-        for time2 in range(0,60,3):
+        for time2 in range(0,var.number_of_point,3):
             if var.bouncetest == False:
                 var.x_pre = (var.x_ini + math.cos(math.radians(var.angle)) * var.speed * time2)
                 var.y_pre = (var.y_ini - (math.sin(math.radians(var.angle)) * var.speed * time2) + 0.5 * var.gravity * time2 ** 2)
@@ -87,10 +94,7 @@
             var.x_val = (var.x_ini + math.cos(math.radians(var.angle)) * var.speed * var.time)
             var.y_val = (var.y_ini - (math.sin(math.radians(var.angle)) * var.speed * var.time) + 0.5 * var.gravity * var.time ** 2)
 
-            if var.y_val + var.ball_surf.get_height() >= var.back_ground_surf.get_height() + 10 or \
-                    var.ball_rect.colliderect(var.hitbox_hopper_rect1) or \
-                    var.ball_rect.colliderect(var.hitbox_hopper_rect2) or \
-                    var.ball_rect.colliderect(var.hitbox_hopper_rect3):
+            if var.y_val + var.ball_surf.get_height() >= var.back_ground_surf.get_height():
                 # Implement bounce
                 var.bounce_sound.play()
                 var.bouncetest=True
@@ -114,6 +118,8 @@
                 var.time = 0
             if var.ball_rect.colliderect(var.hitbox_score_rect) and var.played_test==False :
                 var.win_sound.play()
+                var.shoot_time = current_time
+                var.number_of_point = 70
                 var.played_test=True
                 var.angle = 0.0
                 var.speed = var.memo_speed
@@ -134,10 +140,10 @@
             elif var.x_val + var.ball_surf.get_width() >= var.back_ground_surf.get_width() or var.bounce_count>=3:
                 # Reset ball position and shoot
                 var.loose_sound.play()
+                var.shoot_time = current_time
                 var.shoot = False
                 var.angle = 0.0
                 var.speed = var.memo_speed
-                var.player_rect.midbottom = (random.randint(100, 400),480)
                 var.x_ini = var.player_rect.x + 70
                 var.y_ini = var.player_rect.y + 90
                 var.x_val = var.player_rect.x + 70
@@ -150,6 +156,7 @@
                 var.c = var.a
                 var.ball_rect.center = (var.player_rect.x , var.player_rect.y )
             var.time += 1  # Increment time
+
         text3 = var.score_font.render("{}".format(var.score), True, 'black')
         var.ball_rect.center = (var.x_val, var.y_val)
 
@@ -159,8 +166,6 @@
         screen.blit(var.hitbox_hooper_surf,var.hitbox_hopper_rect2)
         screen.blit(var.hitbox_hooper_surf,var.hitbox_hopper_rect1)
         screen.blit(var.back_ground_surf, var.back_ground_rect)
-        current_time = pygame.time.get_ticks()
-        animation_index = (current_time // var.animation_speed) % len(var.player_animation_surf)
         screen.blit(var.player_animation_surf[animation_index], var.player_rect)
         screen.blit(var.hopper_surf, var.hopper_rect)
         screen.blit(var.ball_surf, var.ball_rect)
@@ -170,7 +175,8 @@
         screen.blit(text3, (430,100))
         screen.blit(var.text1, (20, 510))
         screen.blit(var.text2, (30, 470))
-
+        time_text = var.text_font.render("Time : {}".format(current_time//1000), True, var.color)
+        screen.blit(time_text, (690,540))
         """pygame.draw.rect(screen, 'Green', hopper_rect, 5)
         pygame.draw.rect(screen, 'Red', hitbox_hopper_rect1,5)
         pygame.draw.rect(screen,'Red',hitbox_hopper_rect2,5)
Index: basketball/variables.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport os\r\n\r\nrunning = True\r\ngame_active = True\r\n\r\nclock = pygame.time.Clock()\r\n\r\n# all image(sprite) initialisation :\r\nscreen = pygame.display.set_mode((950, 600))\r\n\r\n\r\nmenu_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Menu.png\")).convert_alpha(), (950, 600))\r\nmenu_rect = menu_surf.get_rect(topleft=(0, 0))\r\nplay_button_surf=pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Play_button.png\")).convert_alpha(), (230, 100))\r\nplay_button_rect=play_button_surf.get_rect(center=(475, 230))\r\nscore_back_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"score back.png\")).convert_alpha(),(100,50))\r\nscore_back_rect = score_back_surf.get_rect(center=(440,122))\r\nback_ground_surf1 = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"basketball court.png\")).convert_alpha(), (950, 600))\r\nback_ground_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"basketball court.png\")).convert_alpha(), (950, 600))\r\nback_ground_rect = back_ground_surf.get_rect(topleft=(0, 0))\r\nplayer_surf = pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player.png\")).convert_alpha(), (70, 180)), True, False)\r\nplayer_rect = player_surf.get_rect(midbottom=(400, 480))\r\nplayer_animation_surf = [pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation1.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation2.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation3.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation4.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation5.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation6.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation7.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation8.png\")).convert_alpha(), (70, 180)), True, False),\r\n                         pygame.transform.flip(pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"Sprite_black_player_animated/Sprite_black_player_animation9.png\")).convert_alpha(), (70, 180)), True, False)]\r\nball_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"basketball ball.png\")).convert_alpha(), (50, 50))\r\nball_rect = ball_surf.get_rect(center=(400, 480))\r\nhopper_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"hooooooop.png\")).convert_alpha(), (180, 300))\r\nhopper_rect = hopper_surf.get_rect(midbottom=(714, 480))\r\npower_gauge_surf = pygame.image.load(os.path.join(\"basketball\",\"assets\",\"power_gauge.png\")).convert_alpha()\r\npower_gauge_rect = power_gauge_surf.get_rect(center=(320, 520))\r\narrow_power_gauge_surf = pygame.transform.scale(pygame.image.load(os.path.join(\"basketball\",\"assets\",\"gauge_arrow.png\")).convert_alpha(),(40,40))\r\narrow_power_gauge_rect = arrow_power_gauge_surf.get_rect(center=(260, 540))\r\nhitbox_hooper_surf = pygame.image.load(os.path.join(\"basketball\",\"assets\",\"hopper_hit_box.png\")).convert_alpha()\r\nhitbox_hopper_rect1 = hitbox_hooper_surf.get_rect(topleft = (hopper_rect.topleft[0]+5,hopper_rect.topleft[1]+20))\r\nhitbox_hopper_rect2 = hitbox_hooper_surf.get_rect(topleft = (hopper_rect.topleft[0]+105,hopper_rect.topleft[1]+20))\r\nhitbox_score_surf = pygame.image.load(os.path.join(\"basketball\",\"assets\",\"hitbox_score.png\")).convert_alpha()\r\nhitbox_score_rect = hitbox_score_surf.get_rect(topleft = (hopper_rect.topleft[0]+45,hopper_rect.topleft[1]+40))\r\nhitbox_hopper_rect3 = hitbox_hooper_surf.get_rect(midleft=(hitbox_score_rect.midleft[0]-40,hitbox_score_rect.midleft[1]-5))\r\nanimation_counter = 0\r\nanimation_speed = 100\r\n# all ball values(parameters):\r\nbounce_count = 0\r\nx_ini = player_rect.x+70\r\ny_ini = player_rect.y+90\r\nx_val = x_ini\r\ny_val = y_ini\r\nx_pre = x_ini\r\ny_pre = y_ini\r\nmass = 100\r\ntime = 0\r\ntime2 = 0\r\ntime3 = 0\r\nretention = 0.95\r\nretention2 = 0.70\r\ngravity = 0.5\r\nshoot = False\r\nangle = 10.0\r\nspeed = 10.0\r\nmemo_speed=speed\r\ntrajectory = False\r\nbouncetest = False\r\nplayed_test = False\r\n#  parameters for gauge\r\na=1\r\nb=-1\r\nc=1\r\narrow_x = 260\r\narrow_y = 540\r\n# text\r\ncolor = 'black'\r\npygame.font.init()\r\nscore = 0\r\nmy_font = pygame.font.SysFont('Comic Sans MS', 30)\r\nmy_font_1 = pygame.font.SysFont('Comic Sans MS', 50)\r\nscore_font = pygame.font.Font(os.path.join(\"basketball\",\"assets\",\"font_score.TTF\"),50)\r\ntext_font = pygame.font.Font(os.path.join(\"basketball\",\"assets\",\"font_score.TTF\"),30)\r\ntext1 = text_font.render(\"Angle : {}\".format(angle), True,color)\r\ntext2 = text_font.render(\"Speed : {}\".format(speed), True,color)\r\n\r\n# sound variables\r\npygame.mixer.init()\r\n\r\nbounce_sound = pygame.mixer.Sound(os.path.join(\"basketball\",\"assets\",\"basketball-ball-hard-hit.wav\"))\r\nball_Sound = pygame.mixer.Sound(os.path.join(\"basketball\",\"assets\",\"throw_sound.wav\"))\r\nball_Sound.set_volume(0.5)  # Set volume to 50%\r\nwin_sound = pygame.mixer.Sound(os.path.join(\"basketball\",\"assets\",\"yeahoo.wav\"))\r\nwin_sound.set_volume(0.3)  # Set volume to 30%\r\nloose_sound = pygame.mixer.Sound(os.path.join(\"basketball\",\"assets\",\"wii-sports-bowling-awww.wav\"))\r\nloose_sound.set_volume(0.3)  # Set volume to 30%
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/basketball/variables.py b/basketball/variables.py
--- a/basketball/variables.py	(revision 0da02c6a71039a6a74c8400d820c103371daf9e0)
+++ b/basketball/variables.py	(date 1715017616919)
@@ -9,7 +9,6 @@
 # all image(sprite) initialisation :
 screen = pygame.display.set_mode((950, 600))
 
-
 menu_surf = pygame.transform.scale(pygame.image.load(os.path.join("basketball","assets","Menu.png")).convert_alpha(), (950, 600))
 menu_rect = menu_surf.get_rect(topleft=(0, 0))
 play_button_surf=pygame.transform.scale(pygame.image.load(os.path.join("basketball","assets","Play_button.png")).convert_alpha(), (230, 100))
@@ -58,8 +57,9 @@
 time = 0
 time2 = 0
 time3 = 0
+shoot_time=0
 retention = 0.95
-retention2 = 0.70
+retention2 = 0.68
 gravity = 0.5
 shoot = False
 angle = 10.0
@@ -68,6 +68,8 @@
 trajectory = False
 bouncetest = False
 played_test = False
+number_of_point = 70
+last_action_time = 0
 #  parameters for gauge
 a=1
 b=-1
@@ -87,7 +89,6 @@
 
 # sound variables
 pygame.mixer.init()
-
 bounce_sound = pygame.mixer.Sound(os.path.join("basketball","assets","basketball-ball-hard-hit.wav"))
 ball_Sound = pygame.mixer.Sound(os.path.join("basketball","assets","throw_sound.wav"))
 ball_Sound.set_volume(0.5)  # Set volume to 50%
Index: .idea/inspectionProfiles/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
--- /dev/null	(date 1714921472731)
+++ b/.idea/inspectionProfiles/profiles_settings.xml	(date 1714921472731)
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1714921472724)
+++ b/.idea/misc.xml	(date 1714921472724)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Black">
+    <option name="sdkName" value="Python 3.9" />
+  </component>
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
Index: .idea/JO-Games.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/JO-Games.iml b/.idea/JO-Games.iml
new file mode 100644
--- /dev/null	(date 1714921472714)
+++ b/.idea/JO-Games.iml	(date 1714921472714)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module version="4">
+  <component name="PyDocumentationSettings">
+    <option name="format" value="PLAIN" />
+    <option name="myDocStringFormat" value="Plain" />
+  </component>
+</module>
\ No newline at end of file
Index: shooting/cleaned_class.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nfrom math import *\r\nimport shooting.ran_gen as rg\r\n\r\nclass Screen(pygame.Surface):\r\n    def __init__(self):\r\n        size=1180,620\r\n        pygame.Surface.__init__(self,size)\r\n        self.screen=pygame.display.set_mode(size,pygame.RESIZABLE)\r\n\r\n\r\nclass Background(pygame.sprite.Sprite):\r\n    def __init__(self,path):\r\n        pygame.sprite.Sprite.__init__(self)\r\n        self.BD=pygame.image.load(path).convert()\r\n\r\n\r\nclass General_Game_Object(pygame.sprite.Sprite):\r\n    def __init__(self,img_path, **kargs):#*args and **kargs are if you don't want to have these values in all the classes but only in some that you created.\r\n        pygame.sprite.Sprite.__init__(self)\r\n        self.sprite=pygame.image.load(img_path).convert_alpha()#The convert alpha should make the transparent pixels in png really transparent in pygame.\r\n        if \"resize\" in kargs:\r\n            self.resize(kargs['resize'])\r\n\r\n    def resize(self,values:tuple[float,float]) -> None:\r\n        self.sprite = pygame.transform.scale(self.sprite,values)\r\n\r\n    def rect(self) ->pygame.rect:\r\n        return self.sprite.get_rect()\r\n    #rect is the position of the sprite.\r\n\r\nclass UFO(General_Game_Object):\r\n    def __init__(self,img_path):\r\n        General_Game_Object.__init__(self,img_path)\r\n        #to define the variables and not have errors.\r\n        self.x=-100\r\n        self.y=-100\r\n        \r\n\r\n    def gen_traj(self,scr_size:pygame.rect) -> None:\r\n        param=rg.gen_eq(scr_size)\r\n        acc=1\r\n        self.traj=Trajectory(False,param[0],param[1],acc*param[2],startpos=param[3])\r\n        self.time=0\r\n\r\n    def move(self,fps:int,screen_size:pygame.rect) -> None:\r\n        self.time+=1/fps\r\n        self.x,self.y=self.traj.position(self.time,True,screen_size)\r\n\r\n    def draw(self,screen:Screen) -> None:\r\n        screen.blit(self.sprite,[self.x,self.y])\r\n\r\n    def check(self,scr_size:pygame.rect) -> bool:\r\n        if not (-100<self.x<scr_size.right): return True\r\n        if not (-100<self.y<scr_size.bottom): return True\r\n        return False\r\n    \r\n    def check_click(self) -> bool:\r\n        mouse_pos=pygame.mouse.get_pos()\r\n        if (pygame.mouse.get_pressed()[0]) and (mouse_pos[0]-self.x)<75 and (mouse_pos[1]-self.y)<75: \r\n            return True\r\n        return False\r\n\r\n\r\nclass Trajectory:\r\n    def __init__(self,use_velocity_vector:bool,launchvelocity:float,angleoflaunch:float,aceleration:float=9.81,start_velocity:tuple=(1,1),startpos:tuple=(0,0)) -> None:\r\n        if use_velocity_vector:\r\n            self.launchvelo=sqrt(start_velocity[0]**2+start_velocity[1]**2) # pythagoras\r\n            self.ax=0 #The acceleration will only be the downward gravity for the moment (simplicity to understand)\r\n            self.bx=start_velocity[0]\r\n\r\n            self.ay=aceleration/2\r\n            self.by=start_velocity[1]\r\n        else:\r\n            self.launchvelo=launchvelocity\r\n            #because we use an euclidian system, we can consider the values beeing one of a right triangle.\r\n            self.ax=0\r\n            self.bx=launchvelocity*sin(angleoflaunch) #values are in radians\r\n\r\n            self.ay=aceleration/2\r\n            self.by=launchvelocity*cos(angleoflaunch) #angleoflaunch is in radians!\r\n\r\n        self.cx=startpos[0]\r\n        self.cy=startpos[1]\r\n\r\n        #This equation represents y(x) and time has been eliminated.\r\n        #The simplification is easy since we have chosen to have ax=0\r\n        self.a=self.ay/(self.bx**2)\r\n        self.b=-(2*self.ay)/(self.bx**2)      +self.by/(self.bx) #see calculations done on a sheet\r\n        self.c=(self.ay*(self.cx**2))/(self.bx**2)    -(self.by*self.cx)/(self.bx)      +self.cy\r\n\r\n        self.equation=f\"y(x)={self.a:8f}xÂ²+{self.b:8f}x+{self.c:8f}\" #the equation is of the form ax^2+bx+c\r\n                                # And the equation of this particular trajectory is stored into this string variable.\r\n                                #this equation is only to be displayed in dev menus not to be used.\r\n        self.startpos=startpos\r\n\r\n    #    x = horizontal motion\r\n    #    y = vertical motion\r\n\r\n    def position(self,time,fixed:bool=False,screen_size:tuple|None=None) -> list:\r\n        x=self.ax*(time**2)+self.bx*time\r\n        y=self.ay*(time**2)+self.by*time\r\n        if fixed: #The equation will be fixed to be calculated in a 10k*10k radius (only positive)\r\n                # And then we render it down to the size of the screen, done here.\r\n            if screen_size==None:\r\n                raise TypeError(\"You need to give the screen size to make the equation a fixed one.\")\r\n            x*=screen_size[2]/10000 #screen size is the rect of the screen.\r\n            y*=screen_size[3]/10000\r\n\r\n        x+=self.cx\r\n        y+=self.cy\r\n        return [x,y]\r\n    \r\n    def trajectory(self,nbpoints:int,starttime=0,maxtime=60,fixed:bool=False,screen_size:tuple|None=None)-> list[list]:\r\n        #maxtime is in seconds\r\n        values=list()\r\n        for i in range(starttime,nbpoints+1): #from time=0 to time=maxtime \r\n            time=i*maxtime/nbpoints\r\n            pos=self.position(time,fixed,screen_size)\r\n            values.append(pos)\r\n        return values
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shooting/cleaned_class.py b/shooting/cleaned_class.py
--- a/shooting/cleaned_class.py	(revision 0da02c6a71039a6a74c8400d820c103371daf9e0)
+++ b/shooting/cleaned_class.py	(date 1714921472696)
@@ -97,7 +97,7 @@
     #    x = horizontal motion
     #    y = vertical motion
 
-    def position(self,time,fixed:bool=False,screen_size:tuple|None=None) -> list:
+    def position(self,time,fixed:bool=False,screen_size:tuple=None) -> list:
         x=self.ax*(time**2)+self.bx*time
         y=self.ay*(time**2)+self.by*time
         if fixed: #The equation will be fixed to be calculated in a 10k*10k radius (only positive)
@@ -111,7 +111,7 @@
         y+=self.cy
         return [x,y]
     
-    def trajectory(self,nbpoints:int,starttime=0,maxtime=60,fixed:bool=False,screen_size:tuple|None=None)-> list[list]:
+    def trajectory(self,nbpoints:int,starttime=0,maxtime=60,fixed:bool=False,screen_size:tuple=None)-> list[list]:
         #maxtime is in seconds
         values=list()
         for i in range(starttime,nbpoints+1): #from time=0 to time=maxtime 
